<?xml version="1.0" encoding="UTF-8"?>
<!--
This software is in the public domain under CC0 1.0 Universal plus a
Grant of Patent License.

To the extent possible under law, the author(s) have dedicated all
copyright and related and neighboring rights to this software to the
public domain worldwide. This software is distributed without any
warranty.

You should have received a copy of the CC0 Public Domain Dedication
along with this software (see the LICENSE.md file). If not, see
<http://creativecommons.org/publicdomain/zero/1.0/>.
-->
<services xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://moqui.org/xsd/service-definition-2.1.xsd">

    <service verb="create" noun="Employment">
        <in-parameters>
            <auto-parameters entity-name="mantle.party.PartyRelationship" include="nonpk"/>
            <auto-parameters entity-name="mantle.humanres.employment.Employment" include="nonpk"/>
            <parameter name="fromPartyId" required="true"/>
            <parameter name="toPartyId" required="true"/>
            <parameter name="fromRoleTypeId" default-value="Employee"/>
            <parameter name="relationshipTypeEnumId" default-value="PrtEmployee"/>
            <parameter name="toRoleTypeId" default-value="OrgEmployer"/>
            <parameter name="fromDate" default="ec.user.nowTimestamp"/>
            <parameter name="parentEmploymentId"/>
        </in-parameters>
        <out-parameters><parameter name="partyRelationshipId"/></out-parameters>
        <actions>
            <entity-find entity-name="mantle.party.PartyRelationship" list="partyRelList">
                <econdition field-name="fromPartyId" from="fromPartyId"/>
                <econdition field-name="toPartyId" from="toPartyId"/>
                <econditions combine="or">
                    <econdition field-name="fromDate" operator="greater-equals" from="fromDate"/>
                    <econdition field-name="thruDate" operator="greater" from="fromDate"/>
                    <econditions>
                        <econdition field-name="fromDate" operator="less" from="fromDate"/>
                        <econdition field-name="thruDate" operator="is-null"/>
                    </econditions>
                </econditions>
            </entity-find>

            <if condition="partyRelList">
                <return error="true" message="Cannot have overlapping employments."/>
            </if>

            <if condition="emplPositionId">
                <!-- If a position is specified, make sure it is valid for the toPartyId -->
                <entity-find-one entity-name="mantle.humanres.position.EmplPosition" value-field="emplPosition">
                    <field-map field-name="emplPositionId"/>
                </entity-find-one>
                <if condition="!emplPosition || (emplPosition.organizationPartyId &amp;&amp; toPartyId != emplPosition.organizationPartyId)">
                    <entity-find-one entity-name="mantle.party.PartyDetail" value-field="toParty">
                        <field-map field-name="partyId" from="toPartyId"/>
                    </entity-find-one>
                    <set field="orgName" from="ec.resource.expand('PartyNameTemplate','',toParty)"/>
                    <return error="true" message="Position ${emplPosition.description} is not valid for ${orgName}"/>
                </if>
            </if>
            <service-call name="create#mantle.party.PartyRelationship" in-map="context" out-map="context"/>
            <service-call name="create#mantle.humanres.employment.Employment" in-map="context"/>
        </actions>
    </service>
    <service verb="update" noun="Employment">
        <in-parameters>
            <parameter name="partyRelationshipId" required="true"/>
            <auto-parameters entity-name="mantle.party.PartyRelationship" include="nonpk"/>
            <auto-parameters entity-name="mantle.humanres.employment.Employment" include="nonpk"/>
            <!-- use PartyContent instead
            <parameter name="identityDocumentFile" type="org.apache.commons.fileupload.FileItem"/>
            <parameter name="emplAuthzDocumentFile" type="org.apache.commons.fileupload.FileItem"/>
            -->
        </in-parameters>
        <actions>
            <!-- use PartyContent instead
            <if condition="identityDocumentFile != null &amp;&amp; identityDocumentFile.size &gt; 0">
                <if condition="!identityLocation">
                    <set field="filename" from="identityDocumentFile.getName()"/>
                    <set field="contentRoot" from="ec.user.getPreference('mantle.content.root') ?: 'dbresource://mantle/content'"/>
                    <set field="identityLocation" value="${contentRoot}/employment/${partyRelationshipId}/identity/${filename}"/>
                </if>
                <set field="docRr" from="ec.resource.getLocationReference(identityLocation)"/>
                <script>
                    fileStream = identityDocumentFile.getInputStream()
                    try { docRr.putStream(fileStream) } finally { fileStream.close() }
                </script>
            </if>
            <if condition="emplAuthzDocumentFile != null &amp;&amp; emplAuthzDocumentFile.size &gt; 0">
                <if condition="!emplAuthzLocation">
                    <set field="filename" from="emplAuthzDocumentFile.getName()"/>
                    <set field="contentRoot" from="ec.user.getPreference('mantle.content.root') ?: 'dbresource://mantle/content'"/>
                    <set field="emplAuthzLocation" value="${contentRoot}/employment/${partyRelationshipId}/emplAuthz/${filename}"/>
                </if>
                <set field="docRr" from="ec.resource.getLocationReference(emplAuthzLocation)"/>
                <script>
                    fileStream = emplAuthzDocumentFile.getInputStream()
                    try { docRr.putStream(fileStream) } finally { fileStream.close() }
                </script>
            </if>
            -->

            <entity-find entity-name="mantle.party.PartyRelationship" list="partyRelList">
                <econdition field-name="partyRelationshipId" operator="not-equals" from="partyRelationshipId"/>
                <econdition field-name="fromPartyId" from="fromPartyId"/>
                <econdition field-name="toPartyId" from="toPartyId"/>
                <econditions combine="or">
                    <econdition field-name="fromDate" operator="greater-equals" from="fromDate"/>
                    <econdition field-name="thruDate" operator="greater" from="fromDate"/>
                    <econditions>
                        <econdition field-name="fromDate" operator="less" from="fromDate"/>
                        <econdition field-name="thruDate" operator="is-null"/>
                    </econditions>
                </econditions>
            </entity-find>

            <if condition="partyRelList">
                <return error="true" message="Cannot have overlapping employments."/>
            </if>

            <if condition="emplPositionId">
                <!-- If a position is specified, make sure it is valid for the toPartyId -->
                <entity-find-one entity-name="mantle.humanres.position.EmplPosition" value-field="emplPosition">
                    <field-map field-name="emplPositionId"/>
                </entity-find-one>
                <if condition="!emplPosition || (emplPosition.organizationPartyId &amp;&amp; toPartyId != emplPosition.organizationPartyId)">
                    <entity-find-one entity-name="mantle.party.PartyDetail" value-field="toParty">
                        <field-map field-name="partyId" from="toPartyId"/>
                    </entity-find-one>
                    <set field="orgName" from="ec.resource.expand('PartyNameTemplate','',toParty)"/>
                    <return error="true" message="Position ${emplPosition.description} is not valid for ${orgName}"/>
                </if>
            </if>
            <service-call name="update#mantle.party.PartyRelationship" in-map="context"/>
            <service-call name="store#mantle.humanres.employment.Employment" in-map="context"/>
        </actions>
    </service>
    <service verb="delete" noun="Employment">
        <in-parameters>
            <parameter name="partyRelationshipId" required="true"/>
            <parameter name="fromRoleTypeId" default-value="Employee"/>
            <parameter name="relationshipTypeEnumId" default-value="PrtEmployee"/>
            <parameter name="toRoleTypeId" default-value="OrgEmployer"/>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.party.PartyRelationship" value-field="ptyRel"/>
            <entity-find-one entity-name="mantle.humanres.employment.Employment" value-field="employment"/>
            <if condition="ptyRel &amp;&amp; employment &amp;&amp; (ptyRel.fromRoleTypeId == fromRoleTypeId) &amp;&amp;
                    (ptyRel.relationshipTypeEnumId == relationshipTypeEnumId) &amp;&amp;
                    (ptyRel.toRoleTypeId == toRoleTypeId)"><then>
                <set field="relatedEmpls" from="employment.findRelatedFk(new HashSet(['mantle.party.PartyRelationship']))"/>
                <!-- TODO: Ignore 'mantle.party.PartyRelationship' below and do a deleteWithCascade since party settings probalby shouldn't stop deletion -->
                <set field="relatedPtyRels" from="ptyRel.findRelatedFk(new HashSet(['mantle.humanres.employment.Employment']))"/>
                <iterate list="(relatedEmpls + relatedPtyRels)" entry="relatedValue">
                    <message error="true">Found ${relatedValue.getEntityNamePretty()}. Cannot delete employment.</message>
                </iterate>
                <check-errors/>
                <service-call name="delete#mantle.humanres.employment.Employment" in-map="context"/>
                <service-call name="delete#mantle.party.PartyRelationship" in-map="context"/>
            </then><else>
                <return error="true" message="Cannot find employment relationship"/>
            </else></if>
        </actions>
    </service>
    <service verb="create" noun="EmploymentSalary">
        <description>Create an EmploymentSalary record, getting defaults and checking against min/max amounts on
            PayGrade record from EmplPosition for Employment.</description>
        <in-parameters>
            <parameter name="partyRelationshipId" required="true"/>
            <auto-parameters entity-name="mantle.humanres.employment.EmploymentSalary" include="nonpk"/>
            <parameter name="fromDate" default="ec.user.nowTimestamp"/>
        </in-parameters>
        <out-parameters><parameter name="fromDate"/></out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.humanres.employment.Employment" value-field="employment"/>
            <if condition="!timePeriodTypeId"><set field="timePeriodTypeId" from="employment.timePeriodTypeId"/></if>
            <if condition="!payGradeId">
                <entity-find-related-one value-field="employment" relationship-name="mantle.humanres.position.EmplPosition"
                        to-value-field="emplPosition"/>
                <set field="payGradeId" from="emplPosition.payGradeId"/>
            </if>
            <if condition="payGradeId">
                <entity-find entity-name="mantle.humanres.rate.PayGradeSalary" list="payGradeSalaryList">
                    <date-filter/><econdition field-name="payGradeId"/>
                    <econdition field-name="timePeriodTypeId" ignore-if-empty="true"/>
                    <order-by field-name="-fromDate"/>
                </entity-find>
                <if condition="payGradeSalaryList">
                    <set field="payGradeSalary" from="payGradeSalaryList[0]"/>
                    <if condition="!timePeriodTypeId"><set field="timePeriodTypeId" from="payGradeSalary.timePeriodTypeId"/></if>
                    <if condition="!currencyUomId"><set field="currencyUomId" from="payGradeSalary.currencyUomId"/></if>
                    <if condition="!amount"><set field="amount" from="payGradeSalary.amount"/></if>
                    <if condition="payGradeSalary.minAmount &amp;&amp; amount &lt; payGradeSalary.minAmount">
                        <message>Warning: salary amount ${amount} is less than pay grade minimum amount (${payGradeSalary.minAmount})</message></if>
                    <if condition="payGradeSalary.maxAmount &amp;&amp; amount &gt; payGradeSalary.maxAmount">
                        <message>Warning: salary amount ${amount} is greater than pay grade maximum amount (${payGradeSalary.maxAmount})</message></if>
                </if>
            </if>

            <service-call name="create#mantle.humanres.employment.EmploymentSalary" in-map="context" out-map="context"/>
        </actions>
    </service>


    <!-- Payroll TimePeriod services -->
    <!-- TODO: change to handle PayrollWeek, PayrollBiWeek, etc based on some configuration of what the org will actually use; or this may not be needed at all and TimePeriod records can be created as needed for payroll processing -->
    <service verb="check" noun="NextPayrollTimePeriods">
        <description>
            Ensure that at least current and next TimePeriods exist for PayrollMonth, PayrollQuarter (3 months), PayrollYear.
            If no time periods exist creates fiscal time periods based on calendar (ie fiscal year matches calendar year).
            If time periods do exist but not next time periods, adds next time period starting next day after current.
            This should be run once per month to ensure the next time period exists.
        </description>
        <in-parameters>
            <parameter name="organizationPartyId"/>
            <parameter name="basisDate" type="java.sql.Date" default="new java.sql.Date(ec.user.nowTimestamp.time)"/>
        </in-parameters>
        <actions>
            <script>basisCal = ec.user.getCalendarSafe(); basisCal.setTime(basisDate)</script>
            <entity-find-one entity-name="mantle.party.Organization" value-field="organization">
                <field-map field-name="partyId" from="organizationPartyId"/></entity-find-one>

            <!-- start with PayrollYear and go down so we have parentPeriodId -->
            <entity-find entity-name="mantle.party.time.TimePeriod" list="currentYearList"><date-filter valid-date="new Timestamp(basisDate.time)"/>
                <econdition field-name="partyId" from="organizationPartyId"/><econdition field-name="timePeriodTypeId" value="PayrollYear"/></entity-find>
            <if condition="!currentYearList">
                <!-- no current year... assume fiscal year is calendar year and create one automatically -->
                <script>yearFromCal = basisCal.clone(); yearFromCal.set(Calendar.DAY_OF_YEAR, 1)</script>
                <script>yearThruCal = basisCal.clone(); yearThruCal.set(Calendar.DAY_OF_YEAR, yearThruCal.getActualMaximum(Calendar.DAY_OF_YEAR))</script>
                <service-call name="create#mantle.party.time.TimePeriod" out-map="createTpOut"
                        in-map="[timePeriodTypeId:'PayrollYear', partyId:organizationPartyId,
                            periodNum:yearFromCal.get(Calendar.YEAR), beginningBalance:0, endingBalance:0,
                            periodName:(organization.organizationName + ' ' + yearFromCal.get(Calendar.YEAR)),
                            fromDate:new java.sql.Date(yearFromCal.getTimeInMillis()),
                            thruDate:new java.sql.Date(yearThruCal.getTimeInMillis()), isClosed:'N']"/>
                <set field="yearPeriodId" from="createTpOut.timePeriodId"/>

                <else>
                    <script>yearFromCal = ec.user.getCalendarSafe(); yearFromCal.setTime(currentYearList.first.fromDate)</script>
                    <script>yearThruCal = ec.user.getCalendarSafe(); yearThruCal.setTime(currentYearList.first.thruDate)</script>
                    <set field="yearPeriodId" from="currentYearList.first.timePeriodId"/>
                </else>
            </if>

            <!-- current quarter -->
            <entity-find entity-name="mantle.party.time.TimePeriod" list="currentQuarterList"><date-filter valid-date="new Timestamp(basisDate.time)"/>
                <econdition field-name="partyId" from="organizationPartyId"/><econdition field-name="timePeriodTypeId" value="PayrollQuarter"/></entity-find>
            <if condition="!currentQuarterList">
                <!-- no current quarter... assume fiscal year is calendar year with 4 3-month quarters and create one automatically -->
                <script>quarterNumber = (int) (basisCal.get(Calendar.MONTH)/3)</script>
                <script>quarterFromCal = basisCal.clone(); quarterFromCal.set(Calendar.MONTH, (quarterNumber * 3)); quarterFromCal.set(Calendar.DAY_OF_MONTH, 1)</script>
                <script>quarterThruCal = basisCal.clone(); quarterThruCal.set(Calendar.MONTH, ((quarterNumber + 1) * 3)); quarterThruCal.set(Calendar.DAY_OF_MONTH, 1); quarterThruCal.add(Calendar.DAY_OF_YEAR, -1)</script>
                <service-call name="create#mantle.party.time.TimePeriod" out-map="createTpOut"
                        in-map="[parentPeriodId:yearPeriodId, timePeriodTypeId:'PayrollQuarter', partyId:organizationPartyId,
                            periodNum:(quarterNumber + 1), beginningBalance:0, endingBalance:0,
                            periodName:(organization.organizationName + ' ' + quarterFromCal.get(Calendar.YEAR) + 'Q' + (quarterNumber + 1)),
                            fromDate:new java.sql.Date(quarterFromCal.getTimeInMillis()),
                            thruDate:new java.sql.Date(quarterThruCal.getTimeInMillis()), isClosed:'N']"/>
                <set field="quarterPeriodId" from="createTpOut.timePeriodId"/>

                <else>
                    <script>quarterFromCal = ec.user.getCalendarSafe(); quarterFromCal.setTime(currentQuarterList.first.fromDate)</script>
                    <script>quarterThruCal = ec.user.getCalendarSafe(); quarterThruCal.setTime(currentQuarterList.first.thruDate)</script>
                    <set field="quarterPeriodId" from="currentQuarterList.first.timePeriodId"/>
                </else>
            </if>

            <!-- current month -->
            <entity-find entity-name="mantle.party.time.TimePeriod" list="currentMonthList"><date-filter valid-date="new Timestamp(basisDate.time)"/>
                <econdition field-name="partyId" from="organizationPartyId"/><econdition field-name="timePeriodTypeId" value="PayrollMonth"/></entity-find>
            <if condition="!currentMonthList">
                <!-- no current quarter... assume fiscal year is calendar year with 4 3-month quarters and create one automatically -->
                <script>monthNumber = basisCal.get(Calendar.MONTH)</script>
                <script>monthFromCal = basisCal.clone(); monthFromCal.set(Calendar.DAY_OF_MONTH, 1)</script>
                <script>monthThruCal = basisCal.clone(); monthThruCal.set(Calendar.DAY_OF_MONTH, basisCal.getActualMaximum(Calendar.DAY_OF_MONTH))</script>
                <service-call name="create#mantle.party.time.TimePeriod" out-map="createTpOut"
                        in-map="[parentPeriodId:quarterPeriodId, timePeriodTypeId:'PayrollMonth', partyId:organizationPartyId,
                            periodNum:monthNumber+1, beginningBalance:0, endingBalance:0,
                            periodName:(organization.organizationName + ' ' + monthFromCal.get(Calendar.YEAR) + '-' + (monthNumber + 1)),
                            fromDate:new java.sql.Date(monthFromCal.getTimeInMillis()),
                            thruDate:new java.sql.Date(monthThruCal.getTimeInMillis()), isClosed:'N']"/>
                <set field="monthPeriodId" from="createTpOut.timePeriodId"/>

                <else>
                    <script>monthFromCal = ec.user.getCalendarSafe(); monthFromCal.setTime(currentMonthList.first.fromDate)</script>
                    <script>monthThruCal = ec.user.getCalendarSafe(); monthThruCal.setTime(currentMonthList.first.thruDate)</script>
                    <set field="monthPeriodId" from="currentMonthList.first.timePeriodId"/>
                </else>
            </if>

            <!-- next year -->
            <!-- based on current year see if next exists and if not add one starting the day after and one year long -->
            <script>nextYearFromCal = yearFromCal.clone(); nextYearFromCal.add(Calendar.YEAR, 1); nextYearFromCal.getTimeInMillis()</script>
            <entity-find entity-name="mantle.party.time.TimePeriod" list="nextYearList"><date-filter valid-date="new Timestamp(nextYearFromCal.getTimeInMillis())"/>
                <econdition field-name="partyId" from="organizationPartyId"/><econdition field-name="timePeriodTypeId" value="PayrollYear"/></entity-find>
            <if condition="!nextYearList">
                <script>nextYearThruCal = yearThruCal.clone(); nextYearThruCal.add(Calendar.YEAR, 1); nextYearThruCal.add(Calendar.DAY_OF_MONTH, 5); nextYearThruCal.set(Calendar.DAY_OF_MONTH, 1); nextYearThruCal.add(Calendar.DAY_OF_MONTH, -1); nextYearThruCal.getTimeInMillis()</script>
                <set field="nextYearPeriodName" value="${organization.organizationName} ${nextYearFromCal.get(Calendar.YEAR)}"/>
                <service-call name="create#mantle.party.time.TimePeriod" out-map="createTpOut"
                        in-map="[previousPeriodId:yearPeriodId, timePeriodTypeId:'PayrollYear', partyId:organizationPartyId,
                            beginningBalance:0, endingBalance:0, periodNum:nextYearFromCal.get(Calendar.YEAR),
                            periodName:nextYearPeriodName, fromDate:new java.sql.Date(nextYearFromCal.getTimeInMillis()),
                            thruDate:new java.sql.Date(nextYearThruCal.getTimeInMillis()), isClosed:'N']"/>
                <set field="nextYearPeriodId" from="createTpOut.timePeriodId"/>

                <else>
                    <script>nextYearFromCal = ec.user.getCalendarSafe(); nextYearFromCal.setTime(nextYearList.first.fromDate)</script>
                    <script>nextYearThruCal = ec.user.getCalendarSafe(); nextYearThruCal.setTime(nextYearList.first.thruDate)</script>
                    <set field="nextYearPeriodId" from="nextYearList.first.timePeriodId"/>
                </else>
            </if>

            <!-- next quarter, may be in current or next year -->
            <script>nextQuarterFromCal = quarterFromCal.clone(); nextQuarterFromCal.add(Calendar.MONTH, 3); nextQuarterFromCal.add(Calendar.DAY_OF_MONTH, 5); nextQuarterFromCal.set(Calendar.DAY_OF_MONTH, 1); nextQuarterFromCal.getTimeInMillis()</script>
            <entity-find entity-name="mantle.party.time.TimePeriod" list="nextQuarterList"><date-filter valid-date="new Timestamp(nextQuarterFromCal.getTimeInMillis())"/>
                <econdition field-name="partyId" from="organizationPartyId"/><econdition field-name="timePeriodTypeId" value="PayrollQuarter"/></entity-find>
            <if condition="!nextQuarterList">
                <set field="parentPeriodId" from="(nextQuarterFromCal.getTimeInMillis() &lt; yearThruCal.getTimeInMillis()) ? yearPeriodId : nextYearPeriodId"/>
                <script>nextQuarterThruCal = quarterThruCal.clone(); nextQuarterThruCal.add(Calendar.MONTH, 3); nextQuarterThruCal.add(Calendar.DAY_OF_MONTH, 5); nextQuarterThruCal.set(Calendar.DAY_OF_MONTH, 1); nextQuarterThruCal.add(Calendar.DAY_OF_MONTH, -1); nextQuarterThruCal.getTimeInMillis()</script>
                <script>nextQuarterNumber = (int) (nextQuarterFromCal.get(Calendar.MONTH)/3)</script>
                <set field="nextQuarterPeriodName" value="${organization.organizationName} ${nextQuarterFromCal.get(Calendar.YEAR)}Q${nextQuarterNumber + 1}"/>
                <service-call name="create#mantle.party.time.TimePeriod" out-map="createTpOut"
                        in-map="[parentPeriodId:parentPeriodId, previousPeriodId:quarterPeriodId,
                            timePeriodTypeId:'PayrollQuarter', partyId:organizationPartyId, beginningBalance:0,
                            endingBalance:0, periodNum:nextQuarterNumber+1, periodName:nextQuarterPeriodName,
                            fromDate:new java.sql.Date(nextQuarterFromCal.getTimeInMillis()),
                            thruDate:new java.sql.Date(nextQuarterThruCal.getTimeInMillis()), isClosed:'N']"/>
                <set field="nextQuarterPeriodId" from="createTpOut.timePeriodId"/>

                <else>
                    <script>nextQuarterFromCal = ec.user.getCalendarSafe(); nextQuarterFromCal.setTime(nextQuarterList.first.fromDate)</script>
                    <script>nextQuarterThruCal = ec.user.getCalendarSafe(); nextQuarterThruCal.setTime(nextQuarterList.first.thruDate)</script>
                    <set field="nextQuarterPeriodId" from="nextQuarterList.first.timePeriodId"/>
                </else>
            </if>

            <!-- next month, may be in current or next quarter -->
            <script>nextMonthFromCal = monthFromCal.clone(); nextMonthFromCal.add(Calendar.MONTH, 1); nextMonthFromCal.add(Calendar.DAY_OF_MONTH, 5); nextMonthFromCal.set(Calendar.DAY_OF_MONTH, 1); nextMonthFromCal.getTimeInMillis()</script>
            <entity-find entity-name="mantle.party.time.TimePeriod" list="nextMonthList"><date-filter valid-date="new Timestamp(nextMonthFromCal.getTimeInMillis())"/>
                <econdition field-name="partyId" from="organizationPartyId"/><econdition field-name="timePeriodTypeId" value="PayrollMonth"/></entity-find>
            <if condition="!nextMonthList">
                <set field="parentPeriodId" from="(nextMonthFromCal.getTimeInMillis() &lt; quarterThruCal.getTimeInMillis()) ? quarterPeriodId : nextQuarterPeriodId"/>
                <script>nextMonthNumber = nextMonthFromCal.get(Calendar.MONTH)</script>
                <script>nextMonthThruCal = monthThruCal.clone(); nextMonthThruCal.add(Calendar.MONTH, 1); nextMonthThruCal.add(Calendar.DAY_OF_MONTH, 5); nextMonthThruCal.set(Calendar.DAY_OF_MONTH, 1); nextMonthThruCal.add(Calendar.DAY_OF_MONTH, -1); nextMonthThruCal.getTimeInMillis()</script>
                <set field="nextMonthPeriodName" value="${organization.organizationName} ${nextMonthFromCal.get(Calendar.YEAR)}-${nextMonthNumber + 1}"/>
                <service-call name="create#mantle.party.time.TimePeriod" out-map="createTpOut"
                        in-map="[parentPeriodId:parentPeriodId, previousPeriodId:monthPeriodId,
                            timePeriodTypeId:'PayrollMonth', partyId:organizationPartyId, beginningBalance:0,
                            endingBalance:0, periodNum:nextMonthNumber+1, periodName:nextMonthPeriodName,
                            fromDate:new java.sql.Date(nextMonthFromCal.getTimeInMillis()),
                            thruDate:new java.sql.Date(nextMonthThruCal.getTimeInMillis()), isClosed:'N']"/>

                <else>
                    <!-- this the last set, nothing will use these but leaving as a placeholder in case this is expanded:
                    <script>nextMonthFromCal = ec.user.getCalendarSafe(); nextMonthFromCal.setTime(nextMonthList.first.fromDate)</script>
                    <script>nextMonthThruCal = ec.user.getCalendarSafe(); nextQuarterThruCal.setTime(nextQuarterList.first.thruDate)</script>
                    -->
                </else>
            </if>
        </actions>
    </service>

    <!-- ============ Benefit Related Services ============ -->
    <service verb="accrue" noun="EmploymentBenefits">
        <in-parameters>
            <parameter name="partyRelationshipId" required="true"/>
            <parameter name="timePeriodId" required="true"/>
            <parameter name="payDate" type="Date"><description>Defaults to TimePeriod.estimatedSettleDate?:TimePeriod.thruDate</description></parameter>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.party.PartyRelationship" value-field="partyRelationship" for-update="true"/>
            <entity-find-one entity-name="mantle.humanres.employment.Employment" value-field="employment"/>
            <!-- <set field="position" from="employment.position"/> -->
            <if condition="partyRelationship.fromDate == null">
                <entity-find entity-name="mantle.work.time.TimeEntry" list="timeEntryList" limit="1">
                    <econdition field-name="partyId" from="partyRelationship.fromPartyId"/>
                    <econdition field-name="organizationPartyId" from="partyRelationship.toPartyId"/>
                    <order-by field-name="fromDate"/>
                </entity-find>
                <if condition="!timeEntryList">
                    <return message="No start date set for employee ${partyRelationship.fromPartyId}, not accruing benefits"/>
                </if>
                <service-call name="update#mantle.party.PartyRelationship" in-map="[partyRelationshipId:partyRelationshipId, fromDate:timeEntryList[0].fromDate]"/>
                <set field="partyRelationship.fromDate" from="timeEntryList[0].fromDate"/>
            </if>
            <set field="startDateTime" from="java.time.ZonedDateTime.ofInstant(partyRelationship.fromDate.toInstant(), java.time.ZoneId.systemDefault())"/>

            <!-- make sure there is a EmploymentBenefit record for each EmplPositionBenefit -->
            <set field="benefitList" from="employment.benefits"/>
            <entity-find entity-name="mantle.humanres.position.EmplPositionBenefit" list="positionBenefitList">
                <econdition field-name="emplPositionId" from="employment.emplPositionId"/></entity-find>
            <iterate list="positionBenefitList" entry="posBenefit">
                <if condition="!benefitList.find({ it.benefitTypeEnumId == posBenefit.benefitTypeEnumId })"><then>
                    <!-- accrualStartDate from accrualStartDays, availableDate from availableAfterDays-->
                    <set field="accrualStartDateTime" from="startDateTime.plusDays(posBenefit.accrualStartDays ?: 0)"/>
                    <if condition="posBenefit.availableAfterDaysEnumId == 'EpbAvailAfterDaysOfInactivity'"><then>
                        <service-call name="mantle.humanres.EmploymentServices.check#DaysOfInactivity"
                                      in-map="[partyId:partyRelationship.fromPartyId, organizationPartyId:partyRelationship.toPartyId,
                                               timePeriodId:timePeriodId, availableAfterDays:posBenefit.availableAfterDays, startDateTime:startDateTime]"
                                      out-map="context"/>
                    </then><else>
                        <set field="availableDateTime" from="startDateTime.plusDays(posBenefit.availableAfterDays?: 0)"/>
                    </else></if>
                    <service-call name="create#mantle.humanres.employment.EmploymentBenefit" in-map="[
                            partyRelationshipId:partyRelationshipId, benefitTypeEnumId:posBenefit.benefitTypeEnumId,
                            accrualStartDate:new java.sql.Date(accrualStartDateTime.toInstant().toEpochMilli()),
                            availableDate:new java.sql.Date(availableDateTime.toInstant().toEpochMilli()),
                            employerPaidPercent:posBenefit.employerPaidPercent]"/>
                </then><else>
                    <!-- Check and see if the position benefit has activity dependant conditions and if so check the activity of current employee and adjust the employment benefit availability accordingly -->
                    <if condition="posBenefit.availableAfterDaysEnumId == 'EpbAvailAfterDaysOfInactivity'">
                        <set field="emplBenefit" from="benefitList.find({ it.benefitTypeEnumId == posBenefit.benefitTypeEnumId })"/>
                        <service-call name="mantle.humanres.EmploymentServices.check#DaysOfInactivity"
                                      in-map="[partyId:partyRelationship.fromPartyId, organizationPartyId:partyRelationship.toPartyId,
                                               timePeriodId:timePeriodId, availableAfterDays:posBenefit.availableAfterDays, availableDate: emplBenefit.availableDate]"
                                      out-map="context"/>
                        <service-call name="update#mantle.humanres.employment.EmploymentBenefit" in-map="[
                                    partyRelationshipId:partyRelationshipId, benefitTypeEnumId:emplBenefit.benefitTypeEnumId,
                                    availableDate:new java.sql.Date(availableDateTime.toInstant().toEpochMilli())]"/>
                    </if>
                </else></if>
            </iterate>
            <!-- get fresh locked EmploymentBenefit records -->
            <entity-find entity-name="mantle.humanres.employment.EmploymentBenefit" list="benefitList" for-update="true">
                <econdition field-name="partyRelationshipId"/></entity-find>

            <entity-find-one entity-name="mantle.party.time.TimePeriod" value-field="timePeriod"/>
            <if condition="payDate == null"><set field="payDate" from="timePeriod.timePeriod.estimatedSettleDate?:thruDate"/></if>
            <!-- TODO: This should use of get#TimePeriodInfo instead of calculating inline, possibly allowing it to be passed in as well. -->
            <set field="fromDateTime" from="java.time.ZonedDateTime.ofInstant(java.time.Instant.ofEpochMilli(timePeriod.fromDate.time), java.time.ZoneId.systemDefault())"/>
            <set field="thruDateTime" from="java.time.ZonedDateTime.ofInstant(java.time.Instant.ofEpochMilli(timePeriod.thruDate.time), java.time.ZoneId.systemDefault()).withHour(23).withMinute(59).withSecond(59)"/>
            <set field="thruTimestamp" from="new Timestamp(thruDateTime.toInstant().toEpochMilli())"/>

            <iterate list="benefitList" entry="benefit">
                <!-- get the related EmplPositionBenefit for defaults -->
                <entity-find-one entity-name="mantle.humanres.position.EmplPositionBenefit" value-field="positionBenefit">
                    <field-map field-name="emplPositionId" from="employment.emplPositionId"/>
                    <field-map field-name="benefitTypeEnumId" from="benefit.benefitTypeEnumId"/>
                </entity-find-one>

                <set field="accrualStartDate" from="benefit.accrualStartDate"/>
                <if condition="accrualStartDate == null">
                    <!-- calc from accrualStartDays, set on EmploymentBenefit record -->
                    <set field="accrualStartDateTime" from="startDateTime.plusDays(positionBenefit?.accrualStartDays ?: 0)"/>
                    <set field="accrualStartDate" from="new java.sql.Date(accrualStartDateTime.toInstant().toEpochMilli())"/>
                    <set field="benefit.accrualStartDate" from="accrualStartDate"/>
                    <entity-update value-field="benefit"/>
                </if>

                <set field="accrualMethodEnumId" from="benefit.accrualMethodEnumId ?: positionBenefit?.accrualMethodEnumId"/>
                <set field="accrualHours" from="benefit.accrualHours?: positionBenefit?.accrualHours"/>
                <set field="accrualHourBlock" from="benefit.accrualHourBlock ?: positionBenefit?.accrualHourBlock"/>
                <set field="accrualMaxHours" from="benefit.accrualMaxHours ?: positionBenefit?.accrualMaxHours"/>

                <!-- does it need accrual? must have accrual method and have some days beyond accrualStartDate -->
                <if condition="!accrualMethodEnumId"><continue/></if>
                <if condition="!accrualHours"><continue/></if>
                <if condition="timePeriod.thruDate &lt; accrualStartDate"><continue/></if>

                <!-- calculate accrual based on method -->
                <if condition="accrualMethodEnumId == 'EbamHoursWorked'"><then>
                    <!-- calculate total hours worked for Employment: from TimeEntry with fromDate after accrualStartDate -->
                    <set field="accrualStartTimestamp" from="new Timestamp(java.time.ZonedDateTime.ofInstant(java.time.Instant.ofEpochMilli(accrualStartDate.time), java.time.ZoneId.systemDefault()).withHour(23).withMinute(59).withSecond(59).toInstant().toEpochMilli())"/>
                    <entity-find entity-name="mantle.work.time.TimeEntrySummary" list="teSumList">
                        <econdition field-name="partyId" from="partyRelationship.fromPartyId"/>
                        <econdition field-name="clientPartyId" from="partyRelationship.toPartyId"/>
                        <econdition field-name="fromDate" operator="greater-equals" from="accrualStartTimestamp"/>
                        <econdition field-name="fromDate" operator="less-equals" from="thruTimestamp"/>
                        <select-field field-name="hours"/>
                    </entity-find>
                    <set field="hoursWorked" from="teSumList?.first?.hours ?: 0.0"/>

                    <!-- subtract hours used so far for accruing this benefit to get hours available for accrual -->
                    <entity-find entity-name="mantle.humanres.employment.EmploymentBenefitAccrualSum" list="hoursUsedSumList">
                        <econdition field-name="partyRelationshipId"/>
                        <econdition field-name="benefitTypeEnumId" from="benefit.benefitTypeEnumId"/>
                        <select-field field-name="workHoursUsed"/>
                    </entity-find>
                    <set field="workHoursUsed" from="hoursUsedSumList?.first?.workHoursUsed ?: 0.0"/>
                    <set field="hoursAvailableForAccrual" from="hoursWorked - workHoursUsed"/>

                    <!--<log level="warn" message="pos ${partyRelationshipId} benefit ${benefit.benefitTypeEnumId} start ${accrualStartTimestamp} block ${accrualHourBlock} hours avail ${hoursAvailableForAccrual}"/>-->
                    <if condition="hoursAvailableForAccrual &gt;= accrualHourBlock">
                        <!-- calculate accrual based on blocks of hours available -->
                        <set field="hourBlocks" from="(hoursAvailableForAccrual as BigDecimal).divide(accrualHourBlock, 0, BigDecimal.ROUND_DOWN).intValue()"/>
                        <set field="hoursUsedNow" from="hourBlocks * accrualHourBlock"/>
                        <set field="hoursToAccrue" from="hourBlocks * accrualHours"/>
                        <!--<log level="warn" message="pos ${partyRelationshipId} benefit ${benefit.benefitTypeEnumId} blocks ${hourBlocks} hours used ${hoursUsedNow} hours accrue ${hoursToAccrue}"/>-->

                        <service-call name="create#mantle.humanres.employment.EmploymentBenefitAccrual" in-map="[
                                partyRelationshipId:partyRelationshipId, benefitTypeEnumId:benefit.benefitTypeEnumId,
                                accrualTypeEnumId:'EbatBenefitAccrued', accrualDate:payDate, accruedHours:hoursToAccrue,
                                timePeriodId:timePeriodId, workHoursUsed:hoursUsedNow]"/>
                    </if>
                </then><else-if condition="accrualMethodEnumId == 'EbamPerPaycheck'">
                    <!-- NOTE: don't prorate if timePeriod.fromDate after accrualStartDate, err on the generous side -->
                    <service-call name="create#mantle.humanres.employment.EmploymentBenefitAccrual" in-map="[
                            partyRelationshipId:partyRelationshipId, benefitTypeEnumId:benefit.benefitTypeEnumId,
                            accrualTypeEnumId:'EbatBenefitAccrued', accrualDate:payDate, accruedHours:accrualHours,
                            timePeriodId:timePeriodId]"/>
                </else-if><else-if condition="accrualMethodEnumId == 'EbamPerYearAnniv'">
                    <!-- NOTE this may not be adequate, what if no paycheck for period that crosses anniversary? plan to call for all employees for each period regardless of hours worked, or not -->
                    <!-- NOTE no prorate for transition from per-paycheck or hours worked, intended to be for upcoming year so past doesn't matter -->
                    <!-- if period from is before anniversary and thru is after do it now -->
                    <set field="anniversaryDateTime" from="startDateTime.withYear(fromDateTime.getYear())"/>
                    <if condition="fromDateTime.isBefore(anniversaryDateTime) &amp;&amp; thruDateTime.isAfter(anniversaryDateTime)">
                        <service-call name="create#mantle.humanres.employment.EmploymentBenefitAccrual" in-map="[
                                partyRelationshipId:partyRelationshipId, benefitTypeEnumId:benefit.benefitTypeEnumId,
                                accrualTypeEnumId:'EbatBenefitAccrued', accrualDate:payDate, accruedHours:accrualHours,
                                timePeriodId:timePeriodId]"/>
                    </if>
                </else-if><else-if condition="accrualMethodEnumId == 'EbamPerYearBegin'">
                    <!-- NOTE this may not be adequate, what if no paycheck for period that crosses year boundary? plan to call for all employees for each period regardless of hours worked, or not -->
                    <!-- NOTE no prorate for transition from per-paycheck or hours worked, intended to be for upcoming year so past doesn't matter -->
                    <!-- if period fromDate is in year before thruDate do it now -->
                    <if condition="fromDateTime.getYear() != thruDateTime.getYear()">
                        <service-call name="create#mantle.humanres.employment.EmploymentBenefitAccrual" in-map="[
                                partyRelationshipId:partyRelationshipId, benefitTypeEnumId:benefit.benefitTypeEnumId,
                                accrualTypeEnumId:'EbatBenefitAccrued', accrualDate:payDate, accruedHours:accrualHours,
                                timePeriodId:timePeriodId]"/>
                    </if>
                </else-if><else>
                    <message>Found invalid accrual method ${accrualMethodEnumId} for employment ${partyRelationshipId} benefit ${benefit.benefitTypeEnumId}</message>
                </else></if>

                <!-- NOTE: always accrue what is due, then after calculate total and see if it needs to be adjusted down to max -->
                <entity-find entity-name="mantle.humanres.employment.EmploymentBenefitAccrualSum" list="accrualSumList">
                    <econdition field-name="partyRelationshipId"/>
                    <econdition field-name="benefitTypeEnumId" from="benefit.benefitTypeEnumId"/>
                    <select-field field-name="accruedHours"/>
                </entity-find>
                <set field="accruedTotal" from="accrualSumList ? accrualSumList[0].accruedHours : 0.0"/>
                <if condition="accrualMaxHours &amp;&amp; accruedTotal &gt; accrualMaxHours">
                    <!-- accrued too much, add negative offset to bring down to max -->
                    <set field="offsetHours" from="accrualMaxHours - accruedTotal"/><!-- will be negative number -->
                    <service-call name="create#mantle.humanres.employment.EmploymentBenefitAccrual" in-map="[
                            partyRelationshipId:partyRelationshipId, benefitTypeEnumId:benefit.benefitTypeEnumId,
                            accrualTypeEnumId:'EbatMaximumAdj', accrualDate:payDate, accruedHours:offsetHours,
                            timePeriodId:timePeriodId]"/>
                </if>
            </iterate>
        </actions>
    </service>

    <service verb="use" noun="EmploymentBenefits">
        <in-parameters>
            <auto-parameters entity-name="mantle.humanres.employment.EmploymentBenefitAccrual">
                <exclude field-name="benefitTypeEnumId"/>
                <exclude field-name="partyRelationshipId"/>
            </auto-parameters>
            <parameter name="benefitTypeEnumId" required="true"/>
            <parameter name="partyRelationshipId" required="true"/>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.party.PartyRelationship" value-field="partyRel">
                <field-map field-name="partyRelationshipId"/>
            </entity-find-one>
            <entity-find-one entity-name="mantle.humanres.employment.EmploymentBenefit" value-field="emplBenefit">
                <field-map field-name="benefitTypeEnumId"/>
                <field-map field-name="partyRelationshipId"/>
            </entity-find-one>

            <entity-find entity-name="mantle.humanres.employment.EmploymentBenefitAccrual" list="accrualList">
                <econdition field-name="partyRelationshipId"/>
                <econdition field-name="benefitTypeEnumId"/>
            </entity-find>

            <set field="hoursAccrued" from="0"/>
            <set field="usedHours" from="0"/>
            <iterate list="accrualList" entry="accrual">
                <if condition="accrual.accruedHours >= 0"><then>
                    <set field="hoursAccrued" from="hoursAccrued + accrual.accruedHours"/>
                </then><else>
                    <set field="usedHours" from="usedHours + accrual.accruedHours"/>
                </else></if>
            </iterate>
            <set field="availableHours" from="hoursAccrued + usedHours"/>

            <!-- Check to see if they have available hours and if the benefit is available yet -->
            <if condition="accrualDate &lt; emplBenefit.availableDate">
                <return error="true" message="This benefit is not available yet"/>
            </if>
            <if condition="accruedHours &gt; availableHours">
                <return error="true" message="Not enough available hours"/>
            </if>

            <set field="rateType"/>
            <script>
                switch(benefitTypeEnumId) {
                    case 'EbtPaidFamilyLeave':
                        rateType = 'RatpFamilyLeave'
                        break
                    case 'EbtPaidHoliday':
                        rateType = 'RatpHoliday'
                        break
                    case 'EbtPaidSickLeave':
                        rateType = 'RatpSick'
                        break
                    case 'EbtPaidVacation':
                        rateType = 'RatpVacation'
                        break
                    default:
                        rateType = 'RatpPtoOther'
                        break
                }
            </script>

            <service-call name="mantle.work.TimeServices.store#TimeEntry"
                          in-map="[partyId:partyRel.fromPartyId, clientPartyId:partyRel.toPartyId, rateTypeEnumId:rateType, fromDate: accrualDate, hours: accruedHours]"
                          out-map="timeEntry"/>

            <set field="accruedHours" from="-1 * accruedHours"/>

            <service-call name="create#mantle.humanres.employment.EmploymentBenefitAccrual" in-map="context + [timeEntryId:timeEntry.timeEntryId]"/>
        </actions>
    </service>

    <service verb="check" noun="DaysOfInactivity">
        <in-parameters>
            <parameter name="partyId"/>
            <parameter name="organizationPartyId"/>
            <parameter name="timePeriodId"/>
            <parameter name="availableAfterDays" type="Integer"/>
            <parameter name="availableDate"/>
            <parameter name="startDateTime"/>
        </in-parameters>
        <out-parameters>
            <parameter name="availableDateTime"/>
        </out-parameters>
        <actions>
            <!-- TODO: Efficiency-wise, this is likely to exist in the calling service already. -->
            <service-call name="mantle.party.TimeServices.get#TimePeriodInfo" in-map="[timePeriodId:timePeriodId]" out-map="timePeriodInfo"/>
            <entity-find entity-name="mantle.work.time.TimeEntry" list="periodTimeEntryList">
                <econdition field-name="partyId"/>
                <econdition field-name="organizationPartyId"/>
                <econdition field-name="fromDate" operator="greater-equals" from="timePeriodInfo.fromTimestamp"/>
                <econdition field-name="fromDate" operator="less-equals" from="timePeriodInfo.thruTimestamp"/>
                <order-by field-name="fromDate"/>
            </entity-find>
            <set field="initialDate" from="periodTimeEntryList.size() &lt; 1 ? timePeriodInfo.fromTimestamp : periodTimeEntryList[0].fromDate "/>
            <set field="xDaysAgo" from="java.time.ZonedDateTime.ofInstant(initialDate.toInstant(), java.time.ZoneId.systemDefault())"/>
            <set field="xDaysAgo" from="java.sql.Timestamp.from(xDaysAgo.minusDays(availableAfterDays).toInstant())"/>
            <entity-find entity-name="mantle.work.time.TimeEntry" list="timeEntryList1">
                <econdition field-name="partyId"/>
                <econdition field-name="organizationPartyId"/>
                <econdition field-name="fromDate" operator="less" from="initialDate"/>
                <econdition field-name="fromDate" operator="greater-equals" from="xDaysAgo"/>
                <order-by field-name="fromDate"/>
            </entity-find>
            <if condition="timeEntryList1.size() &lt; 1">
                <set field="startDateTime" from="java.time.ZonedDateTime.ofInstant(initialDate.toInstant(), java.time.ZoneId.systemDefault())"/>
                <set field="availableDateTime" from="startDateTime.plusDays(availableAfterDays?: 0)"/>
            <else>
                <set field="startingDay" from="xDaysAgo"/>
                <set field="xDaysAgo" from="java.time.ZonedDateTime.ofInstant(startingDay.toInstant(), java.time.ZoneId.systemDefault())"/>
                <set field="xDaysAgo" from="java.sql.Timestamp.from(xDaysAgo.minusDays(availableAfterDays).toInstant())"/>
                <entity-find entity-name="mantle.work.time.TimeEntry" list="timeEntryList2">
                    <econdition field-name="partyId"/>
                    <econdition field-name="organizationPartyId"/>
                    <econdition field-name="fromDate" operator="less" from="startingDay"/>
                    <econdition field-name="fromDate" operator="greater-equals" from="xDaysAgo"/>
                    <order-by field-name="fromDate"/>
                </entity-find>
                <if condition="timeEntryList2.size() &lt; 1">
                    <set field="startDateTime" from="java.time.ZonedDateTime.ofInstant(timeEntryList1[0].fromDate.toInstant(), java.time.ZoneId.systemDefault())"/>
                    <set field="availableDateTime" from="startDateTime.plusDays(availableAfterDays?: 0)"/>
                <else>
                    <set field="availableDateTime" from="availableDate ? java.time.ZonedDateTime.ofInstant(availableDate.toInstant(), java.time.ZoneId.systemDefault()): startDateTime"/>
                </else></if>
            </else></if>
        </actions>
    </service>
</services>
